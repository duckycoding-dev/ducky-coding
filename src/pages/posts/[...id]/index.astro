---
import { getCollection } from 'astro:content';
import HolyGrailLayout from '@layouts/HolyGrailLayout/HolyGrailLayout.astro';
import { Image } from 'astro:assets';
import {
  IMAGE_COMMON_SIZES,
  WEBSITE_FIRST_PUBLISHING_DATE,
  WEBSITE_ROOT,
} from '@utils/globals';
import type { ImageMetadata } from 'astro';
import { getImageWidths, matchImageFromGlobImport } from '@utils/images/images';
import Tag from '@components/Tag/Tag.astro';
import Link from '@components/Link/Link.astro';
import MarkdownContent from '@layouts/MarkdownContent/MarkdownContent.astro';
import type { Image as BannerImage } from '@db/features/images/images.model';
import { serverLogger } from '@utils/logs/logger';
import { ImagesService } from '@db/features/images/images.service';
import { postsService } from '@db/features/posts/posts.service';
import DuckyCodingLogo from '@assets/images/DuckyCoding_logo.png';
import { TopicThing, TagThing } from '@utils/jsonld/thing';
import { DuckyCodingBlog } from '@utils/jsonld/blog';
import { AuthorPerson } from '@utils/jsonld/person';

// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const postsEntries = (await getCollection('posts')).filter(
    (post) => post.data.status === 'published',
  );

  const bannerImagesPromises = postsEntries.map((entry) => {
    const imagePath = entry.data.bannerImagePath;
    if (imagePath) {
      return ImagesService.getImageByPath(imagePath);
    }
    return Promise.resolve(undefined);
  });

  const bannerImages: (BannerImage | undefined)[] =
    await Promise.all(bannerImagesPromises);

  return postsEntries.map((entry, id) => ({
    params: { id: decodeURI(entry.id) },
    props: { entry, bannerImage: bannerImages[id] },
  }));
}
// 2. For your template, you can get the entry directly from the prop
const { entry, bannerImage } = Astro.props;

let processedImage: ImageMetadata | undefined;
const imageToFindPath = bannerImage?.path;
const images = import.meta.glob<{ default: ImageMetadata }>(
  `/src/assets/images/**/*.{jpeg,jpg,png,gif,webp,svg}`,
);
if (imageToFindPath) {
  processedImage = await matchImageFromGlobImport(
    images,
    imageToFindPath,
    serverLogger,
  );
}

const postFromDb = await postsService.getPostBySlug(entry.id); // in astro 5 "slug" became "id", which corresponds to the filename of the content file

const bannerImageFromDb = imageToFindPath
  ? await ImagesService.getImageByPath(imageToFindPath)
  : undefined;
const pageUrl = Astro.url.href;

// Create comprehensive JSON-LD structured data for the blog post
const blogPostJsonLd = {
  item: {
    '@context': 'https://schema.org',
    '@type': 'BlogPosting',
    '@id': pageUrl,
    url: pageUrl,
    headline: entry.data.title,
    description: entry.data.summary,
    articleBody: entry.data.content, // TODO: this should probably be entry.body; content is a field that does not match with the actual post content, it's basically a second summary
    author: AuthorPerson(entry.data.author, WEBSITE_ROOT),
    publisher: AuthorPerson(entry.data.author, WEBSITE_ROOT),
    maintainer: AuthorPerson(entry.data.author, WEBSITE_ROOT),
    datePublished: new Date(
      postFromDb?.createdAt || WEBSITE_FIRST_PUBLISHING_DATE,
    ).toISOString(),
    dateModified: new Date(
      postFromDb?.updatedAt ||
        postFromDb?.createdAt ||
        WEBSITE_FIRST_PUBLISHING_DATE,
    ).toISOString(),
    ...(processedImage && {
      image: {
        '@type': 'ImageObject',
        contentUrl: new URL(processedImage.src, WEBSITE_ROOT).href,
        description:
          bannerImageFromDb?.alt ||
          `Post banner cover related to "${entry.data.topicTitle}"`,
      } as const,
    }),
    keywords: entry.data.tags.join(', '),
    articleSection: entry.data.topicTitle,
    inLanguage: entry.data.language || 'en',
    wordCount: entry.data.content.split(' ').length,
    about: TopicThing(entry.data.topicTitle),
    mentions: entry.data.tags.map((tag) => TagThing(tag)),
    isPartOf: DuckyCodingBlog,
    potentialAction: {
      '@type': 'ReadAction',
      target: pageUrl,
    },
  },
} as const;
---

<HolyGrailLayout
  seoProps={{
    title: entry.data.title,
    description: entry.data.summary,
    openGraph: {
      basic: {
        title: entry.data.title,
        type: 'article',
        url: pageUrl,
        image: new URL(processedImage?.src || DuckyCodingLogo.src, WEBSITE_ROOT)
          .href,
      },
      optional: {
        description: entry.data.summary,
        locale: 'en_US',
        siteName: 'DuckyCoding',
        localeAlternate: ['en_GB'],
        determiner: '',
        audio: undefined,
        video: undefined,
      },
      image: {
        url: new URL(processedImage?.src || DuckyCodingLogo.src, WEBSITE_ROOT)
          .href,
        secureUrl: new URL(
          processedImage?.src || DuckyCodingLogo.src,
          WEBSITE_ROOT,
        ).href,
        height: processedImage?.height || DuckyCodingLogo.height,
        width: processedImage?.width || DuckyCodingLogo.width,
        type: `image/${processedImage?.format || DuckyCodingLogo.format}`,
        alt:
          bannerImageFromDb?.alt ||
          `Post banner cover related to "${entry.data.topicTitle}"`,
      },
      article: {
        publishedTime: new Date(
          postFromDb?.createdAt || WEBSITE_FIRST_PUBLISHING_DATE,
        ).toISOString(),
        modifiedTime: new Date(
          postFromDb?.updatedAt ||
            postFromDb?.createdAt ||
            WEBSITE_FIRST_PUBLISHING_DATE,
        ).toISOString(),
        section: entry.data.topicTitle,
        authors: [entry.data.author],
        tags: entry.data.tags,
      },
    },
    twitter: {
      card: 'summary_large_image',
      site: '@ducky_coding',
      creator: '@ducky_coding',
      title: entry.data.title,
      description: entry.data.summary,
      image: new URL(processedImage?.src || DuckyCodingLogo.src, WEBSITE_ROOT)
        .href,
      imageAlt: "DuckyCoding's logo",
    },
    extend: {
      meta: [
        {
          name: 'keywords',
          content: entry.data.tags.join(', '),
        },
      ],
    },
  }}
  jsonLd={blogPostJsonLd}
>
  <section
    class='from-accent-300 to-accent2-300 shadow-comic border-4 bg-gradient-to-br'
  >
    <div class=`grid items-center`>
      {
        bannerImage && processedImage ? (
          <Image
            format='avif'
            src={processedImage}
            alt={
              bannerImage.alt ??
              `Post banner cover related to ${entry.data.topicTitle}`
            }
            title={entry.data.topicTitle}
            loading={'eager'}
            fetchpriority={'high'}
            decoding={'async'}
            class='border-accent aspect-[16/9] justify-self-center object-cover px-4 py-4'
            widths={getImageWidths(processedImage.width)}
            sizes={IMAGE_COMMON_SIZES}
          />
        ) : null
      }
      <section
        class='flex flex-col justify-center gap-2 self-stretch justify-self-center px-8 pt-0 pb-4 md:pt-4'
      >
        <h1
          class='decoration-accent text-center text-4xl font-extrabold wrap-anywhere underline underline-offset-4'
        >
          {entry.data.title}
        </h1>
        <p class='text-center text-lg font-semibold'>
          Written by: {
            entry.data.author.toLowerCase() === 'duckycoding'
              ? 'DuckyCoding (me)'
              : entry.data.author
          }
        </p>
        <div>
          <p class='text-center text-base italic'>
            Read time: {entry.data.timeToRead}
            {entry.data.timeToRead > 1 ? 'minutes' : 'minute'}
          </p>
          {
            postFromDb?.createdAt ? (
              <p class='text-center text-base italic'>
                {`Published on: ${new Date(postFromDb.createdAt).toLocaleDateString()}`}
              </p>
            ) : null
          }
        </div>
        {
          entry.data.tags.length > 0 ? (
            <div class='flex flex-wrap justify-center gap-2'>
              {entry.data.tags.map((tag, index) => {
                if (tag.toLowerCase() === entry.data.topicTitle.toLowerCase()) {
                  return (
                    <Link
                      variant='contained'
                      href={`/topics/${tag.toLowerCase()}`}
                      class='border-secondary rounded-full border-none p-0'
                    >
                      <Tag
                        class={`${index % 2 === 0 ? 'bg-accent2' : 'bg-accent'}`}
                      >
                        {tag}
                      </Tag>
                    </Link>
                  );
                } else {
                  return (
                    <Tag
                      class={`${index % 2 === 0 ? 'bg-accent2' : 'bg-accent'}`}
                    >
                      {tag}
                    </Tag>
                  );
                }
              })}
            </div>
          ) : null
        }
      </section>
    </div>
  </section>
  <MarkdownContent entry={entry} />
  {
    postFromDb?.updatedAt && postFromDb.updatedAt !== postFromDb?.createdAt ? (
      <p class='mt-8 text-center text-base italic'>
        {`Last updated on: ${new Date(postFromDb.updatedAt).toLocaleDateString()}`}
      </p>
    ) : postFromDb?.createdAt ? (
      <p class='mt-8 text-center text-base italic'>
        {`Published on: ${new Date(postFromDb.createdAt).toLocaleDateString()}`}
      </p>
    ) : null
  }
</HolyGrailLayout>
